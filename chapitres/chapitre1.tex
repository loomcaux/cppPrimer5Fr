\chapter{COMMENCER}

Ce chapitre introduit la plupart des éléments de base de C++: types, variables, expressions, déclarations, et les fonctions. En cours de route, nous expliquerons brièvement comment compiler et exécuter un programme.

Après avoir lu ce chapitre et réalisé les différents exercices, vous devriez être capable d'écrire, de compiler et d'exécuter des programmes simples. Les chapitres suivants partiront du principe que vous pouvez utiliser les fonctionnalités présentées dans ce chapitre et expliqueront ces fonctionnalités plus en détail.

\newpage
\textbf{Le secret de la réussite} dans l'apprentissage d'un nouveau langage de programmation est d'écrire des programmes. Dans ce chapitre, nous allons écrire un programme pour résoudre un problème simple pour une librairie. Notre magasin conserve un fichier de transactions ; chacune d'elles enregistrant la vente d'un ou plusieurs exemplaires d'un même livre. Chaque transaction contient trois éléments de données:

\medbreak
\begin{lstlisting}[language=C]
	0-201-70353-X 4 24.99
\end{lstlisting}
\medbreak
Le premier élément est un numéro ISBN (International Standard Book NUmber, l'identifiant unique d'un livre), le second est le nombre de copies qui ont été vendues, et le dernier est le prix auquel chacun de ces exemplaires a été vendu. De temps en temps, le propriétaire de la librairie lit ce fichier et pour chaque livre calcule le nombre d'exemplaires vendus, le revenu total de ce livre et le prix de vente moyen.

Pour pouvoir réaliser ce programme, nous devons parcourir quelques fonctionnalités de base du C++. De plus, nous allons avoir besoin de savoir comment compiler et exécuter un programme.

Bien que nous n'ayons pas encore conçu notre programme, il est facile de deviner que l'on va devoir :

\medbreak
\begin{itemize}
	\item[\textbullet] Définir des variables ;
	\item[\textbullet] Faire l'entrée et la sortie ;
	\item[\textbullet] Utiliser une structure de données qui contiendra les données ;
	\item[\textbullet] Tester si deux enregistrements ont le même ISBN ;
	\item[\textbullet] Créer une boucle qui traitera chaque enregistrement du ficher de transaction.
\end{itemize}
 
\medbreak
Nous allons commencer à nous intéresser à la résolution de ces sous-problèmes en C++, puis nous écrirons notre programme de gestion de librairie.

\section{Écrire un programme simple en C++}
Chaque programme en C++ contient une ou plusieurs \textbf{fonctions}, dont l'une d'entre elles doit être appelée \textbf{main}. Le système d'exploitation exécute un programme C++ en appelant \textit{main}. Voici la syntaxe de base d'une fonction \textit{main} qui pour l'instant ne fait rien, mais renvoie une valeur au système d'exploitation:

\medbreak
\begin{lstlisting}[language=C]
	int main()
	{
		return 0;
	}
\end{lstlisting}
\medbreak

Une définition de fonction comporte quatre éléments: un \textbf{type de valeur renvoyée}, le \textbf{nom de la fonction}, une \textbf{liste de paramètres} (éventuellement vide) entre parenthèses, et le \textbf{corps de la fonction}. Bien que \textit{main} est un peu particulière à certains égards, nous la définissons de la même manière que toute autre fonction.

Dans cet exemple, \textit{main} ne dispose que d'une liste vide de paramètres (indiquée par les parenthèses () qui ne contiennent rien à l'intérieur). Dans la partie 6.2.5 de livre, nous verrons les autres types de paramètres que nous pouvons définir pour la fonction \textit{main}.

La dernière partie d'une définition de fonction, le corps de la fonction, est un \textbf{bloc d'instructions} qui commence par une accolade ouvrante et se termine par une accolade fermante:

\medbreak
\begin{lstlisting}[language=C]
	{
		return 0;
	}
\end{lstlisting}
\medbreak

La seule instruction de ce bloc est \textit{return}, qui est donc l'instruction qui termine la fonction. Comme c'est le cas ici, un \textit{return} peut également renvoyer une valeur à l'appelant de la fonction. Lorsqu'un \textit{return} inclut une valeur, cette valeur renvoyée doit avoir un type compatible avec le type déclaré dans la fonction. Dans cette exemple, le type de retour de \textit{main} est \textit{int} et la valeur retournée est 0, qui donc est un \textit{int}.

\begin{shadebox}Notez le point-virgule à la fin de l'instruction \textit{return}. Les points-virgules marquent la fin de la plupart des instructions en C++. On peut facilement les oublier ce qui conduit à de mystérieux messages d'erreur du compilateur.
\end{shadebox}

Sur la plupart des systèmes, la valeur renvoyée par \textit{main} est un indicateur d'état. Un 0 retourné indique un succès. Un retour différent de zéro a une signification qui est définie par le système. Habituellement, un retour différent de zéro indique le type d'erreur qui s'est produit.

\begin{shadebox}
\textbf{NOTION CLÉ: LES TYPES}

Les types sont l'un des concepts les plus fondamentaux de la programmation et un concept sur lequel nous reviendrons encore et encore dans ce livre. Un type définit à la fois le contenu d'une donnée et les opérations possibles sur cette donnée.

Les données manipulées par nos programmes sont stockées dans des variables et chacune a un type. Lorsque le type d'une variable nommée \textit{v} est \textit{t}, on dit souvent que "v a le type de t" ou, indifféremment, que "v est un t".

\end{shadebox}

\subsection{Compilation et Exécution de Notre Programme}
Après avoir écrit le programme, nous devons le compiler. Comment compiler un programme dépend de votre système d'exploitation et de votre compilateur. Pour plus de détails sur la manière dont votre compilateur fonctionne, consultez le manuel de référence ou demandez à un collègue compétent.

De nombreux compilateurs basés sur PC sont exécutés à partir d'un environnement de développement intégré (IDE). Il s'agit d'un package qui contient : le compilateur et des outils de construction et d'analyse. Ces IDE peuvent être un atout majeur dans le développement de programmes volumineux, mais nécessite un peu de temps pour apprendre à les utiliser efficacement. Apprendre à utiliser de tels environnements dépasse largement le cadre de ce livre.

La plupart des compilateurs, y compris ceux fournis avec un IDE, fournissent une interface en ligne de commande. À moins que ne connaissiez déjà l'IDE, vous trouverez peut-être plus facile de démarrer avec l'interface de ligne de commande. Cela vous permettra de vous concentrer sur l'apprentissage C++ d'abord. De plus, une fois que vous comprenez le langage, l'IDE est susceptible d'être plus facile à apprendre.

\subsubsection{Convention pour les noms de fichier source du programme}

Que vous utilisiez une interface en ligne de commande ou un IDE, la plupart des compilateurs s'attendent à ce que le code source du programme soit stocké dans un ou plusieurs fichiers. Ces fichiers sont appelés: \textbf{les fichiers sources}. Sur la plupart des systèmes, le nom d'un fichier source se termine par une extension, c'est à dire un point suivi de plusieurs caractères. L'extension indique au système que le fichier est un programme C++. Les compilateurs ont adopté certaines conventions au niveau de l'extension. Ainsi, on retrouve habituellement les extensions \textit{.cc}, \textit{.cxx}, \textit{.cpp}, \textit{.cp} et \textit{.C}.

\subsubsection{Utiliser le compilateur en ligne de commande}

Si nous utilisons une interface en ligne de commande, nous compilerons généralement un programme dans une fenêtre de console (tel qu'un terminal shell sur un système UNIX ou l'invite de commande pour Windows). Supposons que notre programme principal soit écrit dans un fichier nommé \textit{prog1.cc}, nous pourrions le compiler en utilisant une commande telle que :

\medbreak
\begin{lstlisting}[language=C]
	$ CC prog1.cc
\end{lstlisting}
\medbreak

où CC nomme le compilateur et \$ est le prompt du terminal. Le compilateur génère un fichier exécutable. Sur Windows, ce fichier exécutable est nommé \textit{prog1.exe}. Les compilateurs UNIX ont tendance à placer leurs exécutables dans des fichiers nommés \textit{a.out}.

Pour lancer cet exécutable sur Windows, il suffit d'écrire le nom de celui sans être obligé de préciser l'extension \textit{.exe} :

\medbreak
\begin{lstlisting}[language=C]
	$ prog1
\end{lstlisting}
\medbreak

Sur certains systèmes, vous devez spécifier explicitement l'emplacement du fichier, même si le fichier est dans le répertoire ou le dossier en cours. Dans ce cas, on écrirait :

\medbreak
\begin{lstlisting}[language=C]
	$ .\prog1
\end{lstlisting}
\medbreak

Le point "." qui précède l'antislash indique que le fichier se trouve dans le répertoire courant.

Pour lancer un exécutable sous UNIX, nous utilisons le nom complet du fichier, y compris l'extension :

\medbreak
\begin{lstlisting}[language=C]
	$ ./a.out
\end{lstlisting}
\medbreak

La valeur renvoyée par \textit{main} est accessible de manière dépendante du système. Sur systèmes UNIX et Windows, après avoir exécuté le programme, vous devez émettre une commande \textit{echo} appropriée.

Sur les systèmes UNIX, on obtient le statut en écrivant :

\medbreak
\begin{lstlisting}[language=C]
	$ echo $?
\end{lstlisting}
\medbreak

Pour obtenir le statut sur Windows, on écrit :

\medbreak
\begin{lstlisting}[language=C]
	$ echo %ERRORLEVEL%
\end{lstlisting}
\medbreak

\begin{shadebox}
	\textbf{LANCER LE COMPILATEUR GNU OU MICROSOFT}
	
	La commande utilisée pour lancer le compilateur C++ varie selon les compilateurs et les systèmes d'exploitation. Les compilateurs les plus courants sont le compilateur GNU et le compilateur Microsoft Visual Studio.Par défaut, la commande pour exécuter le compilateur GNU est \textbf{g++}:
	
	\medbreak
	\begin{lstlisting}[language=C]
		$ g++ -o prog1 prog1.cc
	\end{lstlisting}
	\medbreak
	
	Le symbole \$ est le prompt. Le \textbf{-o prog1} est un argument pour le compilateur et il nomme le fichier dans lequel sera mis le fichier exécutable. La commande génère un fichier exécutable nommé \textbf{prog1} ou \textbf{prog1.exe}, en fonction du système d'exploitation. Sur UNIX, les fichiers exécutables n'ont pas d'extension ; sur Windows, l'extension est \textbf{.exe}. Si l'on n'avait pas mis le \textbf{-o prog1}, le compilateur aurait généré un exécutable appelé \textbf{a.out} sur un système UNIX et \textbf{a.exe} sur Windows. (À noter : selon la version du compilateur GNU que vous utilisez, vous devrez peut-être spécifier \textbf{-std=c++0x} pour activer la prise en charge de C++ 11).   
	
	La commande pour lancer le compilateur Microsoft Visual Studio 2010 est \textbf{cl}:
	
	\medbreak
	\begin{lstlisting}[language=C]
		$ C:\Users\me\Programs> cl /EHsc prog1.cpp
	\end{lstlisting}
	\medbreak
	
	Ici : \textbf{C:/Users/me/Programs>} est le prompt du système et \textbf{/Users/me/Programs} est le nom du répertoire courant (alias: le dossier courant). La commande \textbf{cl} invoque le compilateur, et \textbf{/EHsc} est l'option du compilateur qui active la gestion standard des exceptions. Le compilateur Microsoft génère automatiquement un exécutable avec un nom qui correspond au premier nom du fichier source. L'exécutable a l'extension \textbf{.exe} et le même nom que le ficheir source. Dans notre cas, l'exécutable est nommé \textbf{prog1.exe}.
	
	Les compilateurs incluent généralement des options pour générer des avertissements sur constructions problématiques. C'est généralement une bonne idée d'utiliser ces options. Notre préférence est d'utiliser \textbf{-Wall} avec le compilateur GNU, et utiliser \textbf{/W4} avec les compilateurs Microsoft.
	
	Pour plus d'informations, consultez le guide utilisateur de votre compilateur.
	
\end{shadebox} 

\textbf{EXERCICES SECTION 1.1.1}
\begin{shadebox}
	
	\textbf{Exercice 1.1: }Passez en revue la documentation de votre compilateur et déterminez quelle convention de nommage de fichier il utilise.
	
	\textbf{Exercice 1.2: }Modifiez le programme pour retournez \textbf{-1}. Une valeur de retour -1 est souvent traitée comme un indicateur que le programme a échoué. Recompilez et exécutez votre programme pour voir comment votre système traite une indication de panne du \textit{main}.
\end{shadebox} 

\section{Un premier regard sur les Entrées/Sorties}

Le langage C++ ne définit aucune instruction pour effectuer une entrée ou une sortie (Input/Output).Au lieu de cela, le C++ inclut une bibliothèque standard étendue qui fournit des IO (et de nombreuses autres fonctionnalités).